# 日志系统
用单例模板创建一个全局唯一的loggermanager。确保唯一性。
# 配置系统
约定>配置。做好初始值，用配置覆盖初始值。
回调函数通知变化情况。哪些改动。
static ConfigVarMap &GetDatas()
        {
            static ConfigVarMap s_datas;// 静态，这样可以在类之前初始化
            return s_datas;
        }
设置静态get方法，并且定义静态类，可以确保在类创建之前初始化静态变量。防止内存段错误
变更回调函数组, uint64_t key,要求唯一，一般可以用hash。设置为map是因为functional没有比较函数，放到vector里面不好删除
std::map<uint64_t, on_change_cb> m_cbs;
把callback的key作为static，这样避免key冲突

# 线程
线程需要加锁。pthread_create会调用Thread::run, 确保Thread::run中初始化步骤执行完毕。
thread_local确保每个线程保有一份不一样数据。
禁止拷贝构造和移动构造赋值。
锁(Semaphore)
**封装和RAII**：便于用户使用，而且可以自动管理锁的生命周期。例如把读锁定义在{}中，出了这个{}自动析构函数释放信号。
范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题

类内设置静态函数，方便访问一些变量

自旋锁和互斥锁：一个是忙等，一个是阻塞。前者减少系统调用，适合冲突少的场景。

# 协程
协程是用户级别的线程。协程切换时也要进行CPU上下文切换，但是不进入内核调度（调度队列，优先级，时间片），也不会导致缓存大规模失效。
CPU上下文信息被保存在了栈中。所以协程需要创建栈指针保存上下文信息。

智能指针不足之处：
```
auto raw_ptr = cur.get();
cur.reset();
raw_ptr->back(); // raw_ptr是普通的指针，不参与引用计数。如果不reset cur会导致引用计数无法归零，协程无法释放。这里没释放是因为scheduler还持有引用。
```
如果有指向自己的指针，自己永远释放不了。

# 协程调度 
线程池
协程调度，将线程分配到协程中执行
智能指针：赋值最好用swap而不是直接赋值。直接赋值可能导致计数归0，触发析构函数。

全局变量是选原子量还是锁+信号量：如果是全局变量不涉及代码控制等，最好是原子量实现，无需加锁。

# IO
void contextResize(size_t size);// 如果不预先分配，注册事件时需要频繁的加锁和扩容vector
```
// 对cb进行一次包装。
static void OnTimer(std::weak_ptr<void> weak_cond, std::function<void()> cb) {
    std::shared_ptr<void> tmp = weak_cond.lock();
    if(tmp) {
        cb();// 
    }
}
```
# HOOK
对于所有需要HOOK的IO函数，可以通过创建一个模板类，然后传入function和args，来实现对于所有IO函数的HOOK。
c++ 可变参数

系统非阻塞和用户非阻塞：系统非阻塞是对于整个系统来说，应该是非阻塞的。因为需要用epoll机制。reactor服务器在linux跑得更快。但是对于用户来说，语义是阻塞的。
但是还是可以在协程之间进行切换。也就是说这个阻塞是相对于协程而言的。

# socket
为什么普通 socket 教程从来不讲网卡？因为调用connect等函数的时候，系统让所有网卡监听并且帮你选择网卡。而sylar我们自己枚举和选择。


